# Qdrant Documentation

Based on Context7 research for implementing the RAG-based AI Backend.

## Installation

```bash
pip install qdrant-client
```

## Basic Client Setup

### Synchronous client:

```python
from qdrant_client import QdrantClient

# Connect to local instance
client = QdrantClient(url="http://localhost:6333")

# Or connect to cloud instance
client = QdrantClient(
    url="https://your-cluster-url.qdrant.io",
    api_key="your-api-key"
)
```

### Asynchronous client:

```python
from qdrant_client import AsyncQdrantClient

client = AsyncQdrantClient(
    url="https://your-cluster-url.qdrant.io",
    api_key="your-api-key"
)
```

## Vector Search Operations

### Basic search with vector:

```python
import numpy as np

query_vector = np.random.rand(100)  # Replace with actual embedding
hits = client.search(
    collection_name="my_collection",
    query_vector=query_vector,
    limit=5  # Return 5 closest points
)
```

### Search with filter:

```python
from qdrant_client.http.models import Filter, FieldCondition, MatchValue

search_result = client.search(
    collection_name="test_collection",
    query_vector=[0.2, 0.1, 0.9, 0.7],
    query_filter=Filter(
        must=[
            FieldCondition(
                key="city",
                match=MatchValue(value="London")
            )
        ]
    ),
    limit=1
)
```

### Asynchronous search:

```python
res = await client.search(
    collection_name="my_collection",
    query_vector=np.random.rand(10).tolist(),
    limit=10,
)
```

## Text-based Search (with FastEmbed integration)

### Direct text query (if collection supports it):

```python
search_result = client.query(
    collection_name="demo_collection",
    query_text="This is a query document",
    limit=1
)
print(search_result)
```

## Query Points (Alternative search method):

```python
from qdrant_client import models

search_result = client.query_points(
    collection_name="demo_collection",
    query=models.Document(text="This is a query document", model=model_name)
).points
print(search_result)
```

## Filtering Options

### Range filtering:

```python
from qdrant_client.models import Filter, FieldCondition, Range

hits = client.search(
    collection_name="my_collection",
    query_vector=query_vector,
    query_filter=Filter(
        must=[
            FieldCondition(
                key='rand_number',
                range=Range(
                    gte=3  # greater than or equal to 3
                )
            )
        ]
    ),
    limit=5
)
```

## Collection Operations

### List collections:

```python
collections = client.get_collections()
for collection in collections.collections:
    print(collection.name)
```

### Get collection info:

```python
collection_info = client.get_collection(collection_name="my_collection")
print(collection_info.config)
```

## Search Result Format

Search results return a list of PointStruct objects with:
- `id`: The point ID
- `score`: Similarity score
- `payload`: Additional data stored with the vector
- `vector`: The stored vector (if requested)

Example:
```python
for hit in hits:
    print(f"ID: {hit.id}, Score: {hit.score}, Payload: {hit.payload}")
```

## Key Points for Implementation:

1. Use the existing collection with book embeddings (no need to create new collections)
2. Perform vector search using embeddings generated by fastembed
3. Apply filters if needed to refine search results
4. Use async client for better performance in web applications
5. Extract payload information to get the actual book content that matches the query
6. The score indicates relevance - use this to rank results and determine context quality