---
title: Week 6 - Physics Simulation Fundamentals
description: Introduction to physics simulation, URDF/SDF, sensors, and Unity visualization
tags: [gazebo, physics-simulation, sdf, sensors, unity]
---

# Week 6 - Physics Simulation Fundamentals

Welcome to Module 2: The Digital Twin. This week, we'll explore physics simulation environments that serve as digital twins for physical robots. These environments are crucial for testing and developing robotic systems safely and efficiently.

## Learning Objectives

By the end of this week, you will be able to:
- Understand the principles of physics simulation for robotics
- Create and modify robot models in simulation environments
- Configure sensors in simulation
- Compare different simulation environments (Gazebo vs others)
- Set up basic simulation scenarios

## 1. Introduction to Physics Simulation

Physics simulation is a critical component of modern robotics development. It allows us to:

- Test algorithms without risking physical hardware
- Validate control strategies in a safe environment
- Generate synthetic data for machine learning
- Rapidly iterate on robot designs

### Key Concepts in Physics Simulation

- **Rigid Body Dynamics**: Simulation of solid objects that don't deform
- **Collision Detection**: Identifying when objects intersect
- **Contact Physics**: Modeling forces when objects touch
- **Sensor Simulation**: Emulating real sensors in a virtual environment

## 2. Simulation Environments Overview

### Gazebo (Classic and Garden)
Gazebo is a 3D simulation environment that provides:
- Realistic physics simulation using ODE, Bullet, or DART
- High-quality graphics rendering
- Sensor simulation (cameras, LIDAR, IMU, etc.)
- ROS2 integration

### NVIDIA Isaac Sim
Isaac Sim provides:
- Advanced graphics with RTX rendering
- Synthetic data generation
- AI training environments
- PhysX physics engine

### Unity Robotics
Unity offers:
- High-quality visualization
- Cross-platform deployment
- Asset store with pre-built environments
- VR/AR support

## 3. Robot Description Formats

### SDF (Simulation Description Format)
SDF is Gazebo's native format for describing robots and environments:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <model name="simple_robot">
    <link name="chassis">
      <pose>0 0 0.1 0 0 0</pose>
      <inertial>
        <mass>1.0</mass>
        <inertia>
          <ixx>0.01</ixx>
          <iyy>0.01</iyy>
          <izz>0.01</izz>
        </inertia>
      </inertial>
      <visual name="visual">
        <geometry>
          <box>
            <size>0.5 0.5 0.2</size>
          </box>
        </geometry>
      </visual>
      <collision name="collision">
        <geometry>
          <box>
            <size>0.5 0.5 0.2</size>
          </box>
        </geometry>
      </collision>
    </link>
  </model>
</sdf>
```

### Relationship between URDF and SDF
- URDF is typically converted to SDF for Gazebo simulation
- Tools like xacro can generate SDF directly from URDF
- Both formats describe robot structure but SDF includes simulation-specific parameters

## 4. Gazebo Simulation Setup

### Installing Gazebo Garden
```bash
# For Ubuntu 22.04
sudo apt update
sudo apt install -y gazebo
```

### Basic Gazebo World
A Gazebo world file defines the environment:

```xml
<?xml version="1.0" ?>
<sdf version="1.7">
  <world name="default">
    <light name="sun" type="directional">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.6 0.4 -0.8</direction>
    </light>

    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
            </plane>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
            <specular>0.8 0.8 0.8 1</specular>
          </material>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

## 5. Sensor Simulation

### Camera Sensors
```xml
<sensor name="camera" type="camera">
  <camera>
    <horizontal_fov>1.047</horizontal_fov>
    <image>
      <width>640</width>
      <height>480</height>
      <format>R8G8B8</format>
    </image>
    <clip>
      <near>0.1</near>
      <far>100</far>
    </clip>
  </camera>
  <always_on>true</always_on>
  <update_rate>30</update_rate>
  <visualize>true</visualize>
</sensor>
```

### LIDAR Sensors
```xml
<sensor name="lidar" type="ray">
  <ray>
    <scan>
      <horizontal>
        <samples>640</samples>
        <resolution>1</resolution>
        <min_angle>-1.570796</min_angle>
        <max_angle>1.570796</max_angle>
      </horizontal>
    </scan>
    <range>
      <min>0.1</min>
      <max>10.0</max>
      <resolution>0.01</resolution>
    </range>
  </ray>
  <always_on>true</always_on>
  <update_rate>10</update_rate>
  <visualize>true</visualize>
</sensor>
```

## 6. ROS2 Integration

### Launching Simulation
```python
# launch/robot_simulation.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    world = LaunchConfiguration('world')

    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource([
            PathJoinSubstitution([
                FindPackageShare('gazebo_ros'),
                'launch',
                'gazebo.launch.py'
            ])
        ]),
        launch_arguments={
            'world': world
        }.items()
    )

    return LaunchDescription([
        DeclareLaunchArgument(
            'world',
            default_value=[PathJoinSubstitution([
                FindPackageShare('my_robot_gazebo'),
                'worlds',
                'simple_room.sdf'
            ])],
            description='Choose one of the world files from `/my_robot_gazebo/worlds`'
        ),
        gazebo
    ])
```

## 7. Unity Robotics Simulation

Unity provides a different approach to robotics simulation with its Robotics Simulation package:

### Key Features
- High-quality graphics rendering
- Integration with Unity's physics engine
- Support for reinforcement learning
- VR/AR capabilities

### Basic Unity Robot Setup
1. Import the Unity Robotics Hub
2. Use the Robot Framework for physics
3. Implement ROS2 communication through the ROS TCP Connector

## Practical Exercise

Create a simple robot model in Gazebo with the following components:
1. A mobile base with differential drive
2. A camera sensor
3. A LIDAR sensor
4. A simple world environment
5. ROS2 interface to control the robot

### Requirements
- Gazebo Garden installed
- ROS2 Humble with Gazebo packages
- Basic understanding of URDF/SDF

### Expected Outcome
A working simulation of a mobile robot with sensors that can be controlled through ROS2.

## Summary

This week introduced you to physics simulation environments, which serve as digital twins for physical robots. You learned about different simulation platforms, robot description formats, sensor simulation, and ROS2 integration. These tools form the foundation for testing and developing robotic systems before deployment on physical hardware. Next week, we'll continue exploring simulation environments with more advanced topics.